# SDD Template with Detailed Examples

This document provides comprehensive templates and examples for each required section of a Software Design Document (SDD).

---

## Required SDD Sections

A complete SDD generated by this skill must contain all of the following required sections. Add the optional API Specifications section when the system exposes network APIs or external integration points.

### 1. System Overview
- **Architecture style**: Monolith, microservices, serverless, event-driven, etc.
- **System boundaries**: What's inside vs. outside the system
- **Key decisions**: Major architectural choices and rationale
- **Design principles**: SOLID, DRY, separation of concerns, etc.

**Example:**
```
This system follows a layered monolithic architecture with clear separation between:
- API layer (FastAPI)
- Business logic layer (service classes)
- Data access layer (SQLAlchemy ORM)
- Database layer (PostgreSQL)

Key decision: Chose monolith over microservices due to team size and deployment simplicity.
```

### 2. Architecture Diagram
- **Format**: ASCII art or Mermaid diagram
- **Components**: All major system components
- **Data flow**: How data moves through the system
- **Integrations**: External services and APIs
- **Relationships**: Component dependencies

**Example:**
```
┌─────────────┐
│   Client    │
│  (Browser)  │
└─────┬───────┘
      │ HTTP/JSON
      ▼
┌─────────────┐
│  API Layer  │
│  (FastAPI)  │
└─────┬───────┘
      │
      ▼
┌─────────────┐
│   Service   │
│    Layer    │
└─────┬───────┘
      │
      ▼
┌─────────────┐
│  Data Layer │
│ (SQLAlchemy)│
└─────┬───────┘
      │
      ▼
┌─────────────┐
│  PostgreSQL │
│  Database   │
└─────────────┘
```

### 3. Component Specifications (Optional)
Include this section only when the system has discrete components that warrant their own specs. If not applicable, omit it and cover details in other sections.

For **each** major component (when applicable), include:

- **Purpose**: What this component does and why it exists
- **Location**: Exact file path (e.g., `src/services/auth_service.py`)
- **Public Interface**: Functions/methods with signatures and docstrings
- **Dependencies**: What other components or libraries it uses
- **Error handling**: How errors are caught and handled
- **Code examples**: Actual implementation snippets

**Example:**
```python
### 3.1 Authentication Service

**Purpose**: Manages user authentication, token generation, and session validation.

**Location**: `src/services/auth_service.py`

**Public Interface**:
```python
class AuthService:
    """Handles user authentication and authorization."""

    def authenticate_user(self, username: str, password: str) -> Optional[User]:
        """
        Authenticate user credentials.

        Args:
            username: User's username or email
            password: Plain text password

        Returns:
            User object if authenticated, None otherwise

        Raises:
            AuthenticationError: If authentication fails
        """
        pass

    def generate_token(self, user: User) -> str:
        """Generate JWT token for authenticated user."""
        pass
```

**Dependencies**:
- `bcrypt` for password hashing
- `PyJWT` for token generation
- `src.models.user.User` data model

**Error Handling**:
- Raises `AuthenticationError` for invalid credentials
- Raises `TokenExpiredError` for expired tokens
- Logs all authentication attempts
```

### 4. Data Models and Storage
- **Models**: Use dataclasses, Pydantic models, ORM models, or typed structures
- **Field definitions**: Include type hints and descriptions
- **Relationships**: Associations and ownership
- **Validation**: Field constraints and business rules
- **Storage approach**: SQL, NoSQL, files, external services, or in-memory
- **Schemas**: Provide schema/migration/collection definitions when persistence is used
- **Examples**: Sample data instances

**Example:**
```python
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

@dataclass
class User:
    """User account model."""
    id: int
    username: str
    email: str
    password_hash: str
    created_at: datetime
    last_login: Optional[datetime] = None
    is_active: bool = True
```

**Storage Example (SQL, if applicable):**
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
```

### Optional: API Specifications (if applicable)
If the system exposes network APIs or external integration points, specify endpoints with:

- **Method and path**: HTTP method and URL path
- **Request format**: Headers, query params, body schema
- **Response format**: Success and error responses
- **Status codes**: HTTP status codes returned
- **Authentication**: Required permissions or tokens
- **Error scenarios**: What can go wrong

**Example:**
```
### POST /api/auth/login

**Description**: Authenticate user and return JWT token

**Request**:
```json
{
  "username": "user@example.com",
  "password": "SecurePassword123"
}
```

**Success Response** (200):
```json
{
  "token": "eyJhbGciOiJIUzI1NiIs...",
  "user": {
    "id": 123,
    "username": "user@example.com"
  }
}
```

**Error Response** (401):
```json
{
  "error": "Invalid credentials"
}
```

**Status Codes**:
- 200: Success
- 401: Invalid credentials
- 429: Too many attempts
```

### 5. Technology Stack
- **Format**: Table with layer, technology, version, and purpose
- **All layers**: Frontend, backend, database, infrastructure
- **Versions**: Specific version numbers
- **Justification**: Why each technology was chosen

**Example:**
```
┌────────────────┬────────────┬─────────┬────────────────────────────┐
│ Layer          │ Technology │ Version │ Purpose                    │
├────────────────┼────────────┼─────────┼────────────────────────────┤
│ API Framework  │ FastAPI    │ 0.104.1 │ High-performance REST API  │
│ ORM            │ SQLAlchemy │ 2.0.23  │ Database abstraction       │
│ Database       │ PostgreSQL │ 15.4    │ Relational data storage    │
│ Authentication │ PyJWT      │ 2.8.0   │ JWT token generation       │
│ Password Hash  │ bcrypt     │ 4.1.1   │ Secure password hashing    │
│ Testing        │ pytest     │ 7.4.3   │ Unit and integration tests │
│ Validation     │ Pydantic   │ 2.5.0   │ Request/response validation│
└────────────────┴────────────┴─────────┴────────────────────────────┘
```

### 6. Directory Structure
- **Format**: Tree structure showing all directories and key files
- **Organization**: Logical grouping of code
- **Conventions**: Naming patterns and file organization
- **Special directories**: Config, tests, docs, etc.

**Example:**
```
project/
├── src/
│   ├── __init__.py
│   ├── main.py              # Application entry point
│   ├── api/
│   │   ├── __init__.py
│   │   ├── routes.py        # API route definitions
│   │   └── dependencies.py  # Dependency injection
│   ├── services/
│   │   ├── __init__.py
│   │   ├── auth_service.py
│   │   └── user_service.py
│   ├── models/
│   │   ├── __init__.py
│   │   ├── user.py
│   │   └── base.py
│   ├── db/
│   │   ├── __init__.py
│   │   ├── connection.py
│   │   └── migrations/
│   └── config/
│       ├── __init__.py
│       └── settings.py
├── tests/
│   ├── __init__.py
│   ├── test_auth.py
│   └── test_users.py
├── docs/
│   └── api.md
├── requirements.txt
├── .env.example
└── README.md
```

### 7. Error Handling Strategy
- **Exception hierarchy**: Custom exception classes
- **Error propagation**: How errors flow through layers
- **Logging**: What gets logged and where
- **User feedback**: Error messages shown to users
- **Recovery**: How the system recovers from errors

**Example:**
```python
# Exception hierarchy
class AppException(Exception):
    """Base exception for all application errors."""
    pass

class AuthenticationError(AppException):
    """Raised when authentication fails."""
    pass

class ValidationError(AppException):
    """Raised when data validation fails."""
    pass

# Error handling in API layer
@app.exception_handler(AuthenticationError)
async def auth_error_handler(request: Request, exc: AuthenticationError):
    return JSONResponse(
        status_code=401,
        content={"error": str(exc)}
    )
```

### 8. Testing Strategy

**⛔ CRITICAL: FULLY AUTOMATED TESTING ONLY ⛔**

All tests in this section MUST be fully automated and executable without human interaction.

**FORBIDDEN**: Do NOT specify:
- **Manual GUI testing** - any testing requiring human interaction with graphical interfaces
- **Interactive user testing** - clicking buttons, filling forms, observing UI changes manually
- Manual testing procedures performed by humans
- Human QA verification steps or visual inspection
- Tests requiring user input from keyboard/mouse/GUI clicks
- "Manually verify..." instructions
- "Open the application and check..."
- "Click the button and observe..."
- "Launch the GUI and verify the menu..."
- Exploratory testing tasks performed by humans
- Browser testing without headless automation
- Desktop GUI testing without automation framework
- Mobile app testing requiring physical device interaction
- Any testing that requires a human to be present or observe the UI

**REQUIRED**: All tests MUST be:
- Executable via command-line (e.g., `pytest`, `npm test`, `cargo test`)
- Fully automated with programmatic assertions
- Runnable in headless CI/CD environments
- Zero human interaction required

**What to specify**:
- **Unit tests**: What components are unit tested (with assertions)
- **Integration tests**: What integrations are tested (automated test suites)
- **End-to-end tests**: Workflow testing using headless automation (Selenium, Playwright, etc.)
- **Test coverage targets**: Minimum coverage percentage
- **Test organization**: How automated test suites are structured
- **Mocking strategy**: What gets mocked and how
- **CI/CD integration**: How automated tests run in pipeline
- **Test execution**: Command to run all tests (e.g., `pytest tests/` or `npm test`)

**Example - CORRECT ✅ (Automated Testing)**:
```
Testing Strategy:
- Unit tests: pytest for all service layer functions with >80% coverage
- Integration tests: API endpoint tests using TestClient with database fixtures
- E2E tests: Playwright headless browser tests for critical user workflows
- GUI tests: Playwright automation for login/dashboard UI flows (headless mode)
- Test execution: `pytest tests/` runs all automated tests
- CI: Tests run automatically on every commit via GitHub Actions
```

**Example - WRONG ❌ (Manual GUI Testing)**:
```
Testing Strategy:
- Manual GUI testing: QA team manually clicks through UI flows
- User acceptance testing: Stakeholders manually test features in the application
- Exploratory testing: Testers manually explore edge cases in the GUI
- Manual verification: Developers manually open the app and verify features work
- Browser testing: Manually open Chrome and test each page
```

**Example - WRONG ❌ (Vague GUI Testing)**:
```
Testing Strategy:
- GUI testing: Test the user interface thoroughly
- Frontend testing: Ensure all buttons and forms work correctly
- UI validation: Verify the application looks correct
```
(These are vague and imply manual testing. Be explicit about automation: "Playwright headless tests", "React Testing Library unit tests", etc.)
